import StdIO: all;
import Math: all;
import Array: all;

#define EPSILON         1.0e-8

/*
 * compile with -noLIR -noWLF -noCF !!
 */

inline double my_mod(double a, double b, double d1, double d2)
{
  a1=tod(toi(a/d2));
  a2=a-d2*a1;
  b1=tod(toi(b/d2));
  b2=b-d2*b1;
  t1=a1*b2+a2*b1;
  t2=tod(toi(t1/d2));
  t3=t1-d2*t2;
  t4=d2*t3+a2*b2;
  t5=tod(toi(t4/d1));
  c=t4-d1*t5;

  /*  a1=floor(a/d2);
  a2=a-d2*a1;
  b1=floor(b/d2);
  b2=b-d2*b1;
  t1=a1*b2+a2*b1;
  t2=floor(t1/d2);
  t3=t1-d2*t2;
  t4=d2*t3+a2*b2;
  t5=floor(t4/d1);
  c=t4-d1*t5;
*/ 
  return(c);
}
 
inline double[.] GenRndArray(int n, double seed)
{
  n2 = n*2;
  rnds = genarray([n2], 0d);
  a    = pow(5.0d,13.0d);
  d    = pow(2.0d,46.0d);
  d1   = pow(2.0d,46.0d);
  d2   = pow(2.0d,23.0d);

  rnd = seed;
  for (j=0; j<n2; j++)
    {
      rnd = my_mod(a, rnd, d1, d2);
      rnds[j] = rnd/d;
    }
  return(rnds);
}

inline double[.] take_subgrid( int offset, int spread, double[.] a, int n)
{
  res = with{
    ( . <= [i] <= . ) : a[i*spread+offset];
  } : genarray( [n], 0.0);
  return(res);
}

double, double, double, int[10] group(double seed, int n){
  rnds = GenRndArray(n, seed);
  rndsa = 2d*rnds-1d;
  x = take_subgrid(0, 2, rndsa, n);
  y = take_subgrid(1, 2, rndsa, n);

  print(shape(x));
  print(shape(y));
    
  t = x*x + y*y;
      
  filter = (t<=1d);
  x = with{
    ( .<= i <= .) {
      if( filter[i]) {
        val = x[i] * sqrt(((-2.0) * log(t[i]))/ t[i]);
      } else {
        val = x[i];
      }
    } : val;
  } : modarray(x);
  printf("Pre\n");
  y = with {
    ( .<= [i] <= .) {
      if( filter[i]) {
        val = y[i] * sqrt(((-2.0) * log(t[i]))/ t[i]);
      } else {
        val = y[i];
      }
    } : val;
  } : modarray( y);
  printf("Post\n");
  Q = with {
    ( [0] <= [i] <= [9]) {
      num = with{
        ( [0] <= iv < [n]) {
          if( (filter[iv]) 
              && (tod(i) <= max( fabs(x[iv]), fabs(y[iv])))
              && ( max( fabs(x[iv]), fabs(y[iv])) < tod(i+1)) ) {
                ival = 1;
              } else {
                ival = 0;
              }
        } : ival;
      } : fold( +, 0);
    } : num;
  } : genarray( [10], 0);
  printf("post2\n");
  sxk = with{
    ( [0]<= [iv] < [n]) {
      if( filter[iv]) {
        val = x[iv];
      } else {
        val = 0d;
      } 
    }: val;
  } : fold( +, 0.0); 
      
  syk = with{
    ( [0]<= [iv] < [n]) {
      if( filter[iv]) {
        val = y[iv];
      } else {
        val = 0d;
      }
    } : val;
  } : fold( +, 0.0);

  printf("post3\n");
  return(rnds[n-1], sxk, syk, Q);
}

int main ()
{
  problemSize = FibreScanInt(stdin);
  groups = 1;
  if (problemSize > 25){
    groups = toi(pow(2.0,tod(problemSize-25)));
    problemSize = 25;
  }
    
  n = toi(pow(2.0,tod(problemSize)));
  s    = 271828183.0d;
  seed = s;
  
  sxk = 0.0;
  syk = 0.0;
  Q = genarray([10], 0);

  for (i=0; i < groups; i++){
    seed, sx, sy, q = group(seed,n);
    sxk = sxk+sx;
    sxy = sxk+sy;
    Q = Q + q;
  }  

  verified = false;

  if (n == 24) {
    if((fabs((sxk- (-3.247834652034740e3))/sxk) <= EPSILON) &&
       (fabs((syk- (-6.958407078382297e3))/syk) <= EPSILON)) {
      verified = true;
    }
  } else if (n == 25) {
    if ((fabs((sxk- (-2.863319731645753e3))/sxk) <= EPSILON) &&
        (fabs((syk- (-6.320053679109499e3))/syk) <= EPSILON)) {
      verified = true;
    }
  } else if (n == 28) {
    if ((fabs((sxk- (-4.295875165629892e3))/sxk) <= EPSILON) &&
        (fabs((syk- (-1.580732573678431e4))/syk) <= EPSILON)) {
      verified = true;
    }
  } else if (n == 30) {
    if ((fabs((sxk- (4.033815542441498e4))/sxk) <= EPSILON) &&
        (fabs((syk- (-2.660669192809235e4))/syk) <= EPSILON)) {
      verified = true;
    }
  } else if (n == 32) {
    if ((fabs((sxk- (4.764367927995374e4))/sxk) <= EPSILON) &&
        (fabs((syk- (-8.084072988043731e4))/syk) <= EPSILON)) {
      verified = true;
    }
  }

  print( Q);
  printf( "\n sxk: ");
  print(sxk);
  printf( "\n syk: ");
  print(syk);
  printf( "\n");

  if (verified){
    printf("Verified\n");
  }
  else {
    printf("UNverified\n");
  }

  return(0);
}

