/*
 *     C O N J U G A T E   G R A D I E N T   B E N C H M A R K
 *               S A C   S E R I A L     V E R S I O N 
 *            
 *
 *                 SAC Parallel Benchmark (SPB)
 *                           C G
 *
 * Conjugate Gradient (CG) benchmark is an important scientific kernel 
 * used to evaluate machine performance and compare characteristics of 
 * different programming models.
 *
 *
 * <--! compiling the bechmark with a class X :
 *          sac2c cg-vNumber.sac -DCLASSX     !-->
 */


import StdIO: all;
import Array: all;
import Math : all;

use RTimer: all;
use RandLC: all;    

/*							
 * Multiplying a Matrix formed by a triple:		
 *	(a,rowstr,colidx) and a Vector "p"		
 *							
 * Input: a, rowstr, colidx,p				
 * Output: r						
 *							
 */
inline
double[.] matvecmul( double[.] a, int[.] rowstr, int[.] colidx, double[.] p) {
  n = shape(p);
  q = with {
	([0] <= iv <n){
          res = with {
                  ([rowstr[iv]]<= jv < [rowstr[iv+1]]){
                    res2 = a[jv]*p[[colidx[jv]]];
                  }: res2;
                }: fold(+,0.0d);
	}:res;
      }: genarray(n,0.0d);
  return(q);
}


/*							
 * Conjugate gradient					
 *							
 * Compute approximation of x in Ax = z			
 *							
 * Input: A, x						
 * Output: z, ||r||
 *							
 */
double[.], double cg( double[.] a ,int[.] rowstr, int[.] colidx, double[.] x){
  sum = 0d;  
  z = genarray(shape(x), 0.0d);
  r = x;
  rho = sum(r*r);  
  p = r;
 
  for( i=0; i<25; i++) {
    q = matvecmul(a,rowstr,colidx,p);
    alpha = rho / sum(p * q);
    z = z + (alpha * p);
    r = r - (alpha * q);
    rho0 = rho;
    rho = sum(r*r);
    beta = rho / rho0;
    p = r + (beta * p);
  }

  d = matvecmul(a,rowstr,colidx,z);
  r = d;
  d = x - r;
  s = sum(d*d);
  rnorm = sqrt(s);
  return(z,rnorm);
}



/*
 * Makea						
 *							
 * Genarates the Sparse Matrix A				
 *							
 * Input: n								
 * Output: a, colidx, rowstr				
 *
 *		Variables				
 *	N      : Number of rows and colomns				
 *	NONZER : Number of non zeros			
 *	A      : Array of NZ   				
 *	IA     : Array of NZ row indices		
 *	JA     :					
 *							
 */
double[.], int[.], int[.] makea (int n, int NONZER, int RCOND, int LAMBDA){

  arow = genarray([n],0);
  acol = genarray([n,NONZER+1],-1);
  aelt = genarray([n,NONZER+1],0.0d);

      /* nn1 is the smallest power of 2 not less than n   */ 
  nn1 = 1;
  while (nn1<n) {
    nn1 = nn1 *2;    
  } 
      /*  Generate nonzero positions and save for the use in sparse  */
  tran = 314159265d; amult = 1220703125d;
      /* RandLC ( Linear Congruential Generator ) returns a uniform 
       * pseudorandom real*8 number in the range (0, 1) 
       * by using the linear congruential generator
       */ 
  rlc = create_randlc( tran, amult);
  zeta = randlc(rlc);
  for (i=0;i<n;i++){
    nzv = NONZER;
       /* Generating a sparse n-vector vc and an index vector for column positions ivc */
    vc,ivc = sprnvc(rlc,n,nzv,nn1);
       /* ... the ith element of vc is set to 0.5d to insure that A cannot be structurally singular */
    nzv,vc,ivc = vecset (n,vc,ivc,nzv,i,0.5d);
    arow[i]= nzv; 
    for (ivelt=0; ivelt<nzv; ivelt++){
      acol[[i,ivelt]] = ivc[[ivelt]];
      aelt[[i,ivelt]] = vc[[ivelt]];
    } 
  }
       /*  ... make the sparse matrix from the list of elements with duplicates  */
 a,colidx,rowstr = sparse(arow,acol,aelt,n, NONZER, RCOND, LAMBDA);
return (a,colidx,rowstr);
}



/*							
 * Sprnvc 						
 *							
 * Generate a sparse n-vector (v, iv)			
 *  having nzv nonzeros	 				
 * 							
 * Input: n, nz, nn1 					
 * Output: v, iv 				 
 */
double [.], int[.] sprnvc (RandLC &rlc, int n, int nz, int nn1){
 
  v = genarray([nz+1],0.0d);
  iv = genarray([nz+1],-1);
  nzv = 0;
  
  while(nzv<nz){
    vecelt = randlc(rlc); 
    vecloc = randlc(rlc);

    i = toi(tod(nn1)*vecloc);
    if (i<n) {
      found = false;
      for (ii=0;ii<nzv;ii++){   
	found = found | iv[[ii]] == i;
      }
      if (!found){
        v[[nzv]] = vecelt;
        iv[[nzv]] = i;
        nzv++;
      }
    }
  }
  return(v,iv);
}



/*							
 *  vecset
 * 						
 * the ith element of the vector is set to 1/2 to ensure that A cannot be structurally singular	
 *
 *  Input: n, v, iv, nvz, i, val 								
 *  Output: nvz, v, iv						
 */
int, double [.], int[.] vecset (int n,double[.] v, int[.]iv, int nzv, int i,double val){
    
  set = false;
  for (k=0;k<nzv;k++){ 
 
    if (iv[[k]]==i){
      v = modarray(v,[k],val); 
      set = true;
    }
  }
  if (!set){
    v[[nzv]] = val;
    iv[[nzv]] = i;
    nzv = nzv+1;
  }
  return(nzv,v,iv);
}



/*							
 * Sparse 						
 *							
 * Assembles the matrix data structures			
 *  from the list of triples 				
 * 							
 * Input: arow, acol, aelt						
 * Output: a, rowstr, colidx				
 */
double [.], int[.], int[.] sparse(int[.] arow, int[.,.] acol, double[.,.] aelt,
                                  int n, int NONZER, int RCOND, int LAMBDA) { 
  nz = n *(NONZER+1)*(NONZER+1);

  rowstr = genarray([n+1],0);
  colidx = genarray([nz],-1);
  a = genarray([nz],0.0d); 
  nzloc = genarray([n],0);

  for (i=0;i<n;i++){
    for (nza=0;nza<arow[[i]];nza++){
      j = acol[[i,nza]]+1;   
      rowstr[[j]] = rowstr[[j]] + arow[[i]];
    }
  }
  for (j=1;j<n+1;j++){
    rowstr[[j]] = rowstr[[j]]+rowstr[[j-1]];
  }
        /* ... rowstr[[j]] is now the location of the first nonzero of row j of a */
  nza = rowstr[[n]]-1;   
        /* ... generate actual values by summing duplicates */

  ratio = pow(tod(RCOND),1d/tod(n));
       /* The weights wi are a geometric sequence with a first value w=1d 
        * and the ratio chosen so that wN = 0.1d 
        */
  w = 1d; 
  for (i=0;i<n;i++){
    for (nza=0; nza<arow[[i]]; nza++){
      j = acol[[i,nza]];
      scale = w * aelt[[i,nza]];        
      for (nzrow=0; nzrow<arow[[i]]; nzrow++){
        jcol = acol[[i,nzrow]];
        va = aelt[[i,nzrow]] * scale;
              /* ...add the identity * rcond to the generated matrix 
               * to bound the smallest eigenvalue from below by rcond 
               */
        if ( (jcol==j) & (j==i) ){
          va = va + tod(RCOND) - tod(LAMBDA);
        }
               /* ...insertelts   */
	found = false;
        for (k = rowstr[[j]]; (!found) & (k<=(rowstr[[j+1]]-1)); k++){

          if (colidx[[k]] > jcol){
                 /* ... insert colidx here properly */
            for (kk = (rowstr[[j+1]]-2); kk>=k; kk--){
              if (colidx[[kk]] > -1) {                 
                a[[kk+1]] = a[[kk]];        
                colidx[[kk+1]] = colidx[[kk]];
              }
            }
            colidx[[k]] = jcol;
            a[[k]] = 0d;
            found = true;
          }
          else if (colidx[[k]] == -1){     
          
             colidx[[k]] = jcol;
             found = true;
          }
          else if (colidx[[k]] == jcol){
                 /* ... mark the duplicated entry */
            nzloc[[j]] = nzloc[[j]]+1;
            found = true;
          } 
        }
       a[[k-1]]= a[[k-1]] + va;
      }
    }
    w = w * ratio;
  }
       /* compress:  ...remove empty entries and generate final results   */
  for (j=1; j<n; j++){
    nzloc[[j]] = nzloc[[j]] + nzloc[[j-1]];
  }
  for (j=0;j<n;j++){
    if(j>0){  j1 = rowstr[[j]] - nzloc[[j-1]];   } 
    else   { j1 = 0;  }
    j2 = rowstr[[j+1]] - nzloc[[j]] - 1;
    nza = rowstr[[j]];
    for (k=j1; k<=j2; k++){
      a[[k]] = a[[nza]];
      colidx[[k]] = colidx[[nza]];
      nza = nza+1; 
    }
  }
  for (j=1; j<n+1; j++){                             
    rowstr[[j]] = rowstr[[j]] - nzloc[[j-1]];
  }   
  nza = rowstr[[n+1]]-1;
       /* ... end of compress */ 
  return(a,colidx,rowstr);
} 

#if 0
/*
 * getStartTime, getEndtTime
 *
 * ... get the starting and the ending time for measuring the process of 
 * the conjugate gradient Method CG
 */
ptime, int getStartTime( int n) {
  return( getptime(), n);
}

ptime, double getEndTime( double d) {
  return( getptime(), d);
}


/*
 * getinitStarta, getinitStopa
 *
 * ... get the starting and the ending time for measuring the process of initialisation 
 * and the process of generating a matrix A formed by a triple (a, colidx, rowstr) 
 */

ptime, double[.] getinitStarta( double[.] a) {
  return( getptime(), a);
}

ptime, double[.] getinitStopa( double[.] a) {
  return( getptime(), a);
}

#endif


/** <!--********************************************************************-->
 *
 *                      M A I N    P R O G R A M
 *                Conjugate Gradient Benchmark - SAC Version
 *
 ******************************************************************************/
int main() {

/* N                 : Number of rows & columns
 * NITER             : Number of iterations
 * LAMBDA            : Shift of the main diagonal of a sparse Matrix A
 * NONZER            : Number of non zeros
 * ZETA_VERIFY_VALUE : The correct Zeta
 */
  N = FibreScanIntArray();
  NITER = (int) FibreScanIntArray();
  LAMBDA = (int) FibreScanIntArray();
  NONZER = (int) FibreScanIntArray();
  ZETA_VERIFY_VALUE = (double) FibreScanDoubleArray();

  printf("\n\n SAC Parallel Benchmarks (NPB3.2-SAC)"
              " - CG Benchmark\n");

  rtimer = createRTimer( );

  n = N; nz = n *(toi(NONZER)+1)*(toi(NONZER)+1);
  a = genarray([nz],0d);
       /* ... Measure Initialisation Time  */
  startRTimer( rtimer);
       /* ... generate the input sparse Matrix A which is formed by a triple (a, colidx, rowstr) */
  a,colidx,rowstr = makea(n, toi(NONZER), NONZER, LAMBDA);
  x = genarray([n],1d);
  zeta = 0d;
  stopRTimer( rtimer);
  
       /* ... End Measure Initialisation Time  */
  init_time = getRTimerDbl( rtimer);

  printf("\n Size       : %d\n"
        " Iterations : %d\n"
        "\n Initialisation time = %f seconds",N,NITER,init_time);

  printf("\n\n   iteration          ||r||                 zeta\n");

  resetRTimer( rtimer);
  
  /* ... Start Timimg Here  */
  startRTimer( rtimer);
  
  for (it=1;it<=NITER;it++){ 
    z,rnorm = cg(a,rowstr,colidx, x);
    zeta = tod(LAMBDA) + (1d/(sum(x*z)));
    printf("\n       %2d       %.14E    %.13f",it,rnorm,zeta);
    x = z*(1d/sqrt(sum(z*z)));    
  }
  stopRTimer( rtimer);
  /* ... End Timing Here  */

  elapsed = getRTimerDbl( rtimer);
  printf("\n Benchmark Completed\n");
       /* epsilon = 0.00000000001d */
  epsilon = pow(1d,-10d); 
  err = fabs(zeta - ZETA_VERIFY_VALUE)/ ZETA_VERIFY_VALUE;

  if (err <= epsilon){
    verified = true;
    verif = "SUCCESSFUL";
    printf(" VERIFICATION SUCCESSFUL\n Zeta is\t %.14E\n"
        " Error is\t %.14E\n",zeta,err);
  }
  else {
    verified = false;
    verif = "UNSUCCESSFUL";
    printf(" VERIFICATION FAILED\n Zeta is\t\t %f\n"
        " The correct zeta is\t %f\n",zeta,ZETA_VERIFY_VALUE);
  }

  if( elapsed != 0d ) { 
    mflops = tod( 2*NITER*N ) * ( 3d+tod( NONZER*(NONZER+1) )+ 25d *(5d +tod( tod(NONZER)*(tod(NONZER)+1d) ))+ 3d ) / elapsed / 1000000.0d;
  }
  else mflops = 0d;
  printf("\n\n CG Benchmark Completed.\n");

  printf(" Size\t\t =\t%d\n"			/*	Problem size	*/
         " Iterations\t =\t%d\n"
         " Time in seconds =\t%f\n"
         " Mop/s total     =\t%f\n"		/*        RATE	       */
         " Operation type  =\tfloating point\n"
         " Verification    =\t%s\n"
         " Version\t =\t3.2.1\n"
         " Compile date\t =\t"__DATE__"  \n\n\n",
         N,NITER,elapsed,mflops,verif);

  return(0);
}
